\section{Introduction}\label{sec:intro}


Isosurface extraction to produce geometric models of surfaces from volumetric data is important in many applications. It is often used for indirect visualization of the medical data or for flow modeling \cite{Rohan2018a}. 
% In this paper we suggest an approach based on 
 
% Input volumetric data are represented by a 3D voxel field and can be generated by segmentation of sections from computed tomography. 
The most popular algorithm used for surface extraction is probably Marching Cubes (MC). The algorithm was described by Lorentsen and Cline \cite{Lorensen1987} in 1987. The survey of Marching Cubes algorithms has been published in 2006 \cite{Newman2006}. The algorithm is based on considering the cube defining volume. Each corner vertex of the cube is related to input volumetric data. MC traverse the data and constructs the surface by using a lookup table of different triangular faces depending on different patterns of the cube.  The main disadvantages of this method are time requirements, ambiguity, and holes generation. Some of them were discovered shortly after the algorithm was introduced. 
Marching Cubes. In 1991 Nielson and Hamman described an Asymptotic Decider to solve the ambiguity problem on the faces of the cube.  Natarajan noted that the ambiguity problem also occurs with uniform samples \cite{Natarajan1994}. In 1995 Chernyaev extended the number of cases to 33 \cite{chernyaev1995marching}. More recently the algorithm was updated by Custodio, Pesco, and Silva to enhance the quality of iso-surface triangulation \cite{Custodio2019}. 

Some alternative methods have been developed, including a method for surface extraction using particle attraction; a system was described by Crossno and Angel in \cite{Crossno1997}. A graph processing that tracks the boundary cell-face adjacencies is described in \cite{Lachaud2000}. Some parallel algorithms for iso-surface extraction are discussed in \cite{Bajaj2004}.
A completely data-parallel algorithm, implemented in OpenCL that runs entirely on the GPU is presented in~\cite{Smistad12}. 
A Linear Algebraic Representation approach, parallelized using the OpenCL framework on Linux, was discussed in~\cite{Paoluzzi2016}. % \cite{paodcvjcadanda2015}.

% In this paper
% TODO slightly change the formulation
Here we discuss an alternative approach for surface extraction. Our \textsc{lar-surf} (Linear Algebraic Representation Surface extraction) filter is based on basic algebraic topology and linear algebra, using linear spaces $C_p$ of chains (of cells) of dimension $0 \leq p \leq 3$ and the boundary matrix $[\partial_3] : C_3 \to C_2$.

Input volumetric data are represented by a 3D voxel array and can be generated by segmentation computed tomography (upper left image on Fig. \ref{fig:example_liver_macro_micro}). A decomposition of the input volumetric data into small submatrices called \emph{bricks} is performed, then the binary coordinate vector of each interesting chain of voxels is generated, and its boundary is computed by matrix multiplication times the boundary matrix producing the binary representation of the boundary surface (the surface which defines the boundary). 
Embarrassing parallel data decomposition is used to compute the boundary surface patches within each of the bricks, that are finally joined and smoothed via the Taubin algorithm \cite{Taubin1995}.

The present paper is organized as follows.
Section~\ref{sec:background} provides the basic topological and geometrical concepts needed to understand the \textsc{lar-surf} method, including the building of boundary matrices, the map from Cartesian indices to linear indices, and the Taubin smoothing method.
Section~\ref{sec:filter} discusses the parametric design of the unit block filtered by the parallel algorithm, including the block decomposition, the sparsity rate of the used sparse arrays, and the block-level parallelism.
Section~\ref{sec:julia} is related to the algorithm implementation in Julia, and in particular to a discussion of the parallel workflow.
Section~\ref{sec:examples} presents some examples of algorithm execution on the liver and the hepatic portal system.
Section~\ref{sec:conclusion} shortly describes the next extensions of this approach, in particular the implementation with Julia's support for GPU parallelism and the multi-segmentation of Medical images.
